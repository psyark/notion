package notion

import (
	"encoding/json"
	"fmt"
	uuid "github.com/google/uuid"
)

// Code generated by notion.doc2api; DO NOT EDIT.
// https://developers.notion.com/reference/post-database-query-filter

// The filter object
type Filter interface {
	isFilter()
	GetProperty() string
}
type FilterCommon struct {
	Property string `json:"property,omitempty"` // The name of the property as it appears in the database, or the property ID.
}

func (c *FilterCommon) GetProperty() string {
	return c.Property
}

type filterUnmarshaler struct {
	value Filter
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "" field of the message.
*/
func (u *filterUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	t := struct {
		Checkbox    json.RawMessage `json:"checkbox"`
		Date        json.RawMessage `json:"date"`
		Files       json.RawMessage `json:"files"`
		Formula     json.RawMessage `json:"formula"`
		MultiSelect json.RawMessage `json:"multi_select"`
		Number      json.RawMessage `json:"number"`
		People      json.RawMessage `json:"people"`
		Relation    json.RawMessage `json:"relation"`
		RichText    json.RawMessage `json:"rich_text"`
		Rollup      json.RawMessage `json:"rollup"`
		Select      json.RawMessage `json:"select"`
		Status      json.RawMessage `json:"status"`
		Timestamp   json.RawMessage `json:"timestamp"`
		And         json.RawMessage `json:"and"`
		Or          json.RawMessage `json:"or"`
	}{}
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	switch {
	case t.Checkbox != nil:
		u.value = &CheckboxFilter{}
	case t.Date != nil:
		u.value = &DateFilter{}
	case t.Files != nil:
		u.value = &FilesFilter{}
	case t.Formula != nil:
		u.value = &FormulaFilter{}
	case t.MultiSelect != nil:
		u.value = &MultiSelectFilter{}
	case t.Number != nil:
		u.value = &NumberFilter{}
	case t.People != nil:
		u.value = &PeopleFilter{}
	case t.Relation != nil:
		u.value = &RelationFilter{}
	case t.RichText != nil:
		u.value = &RichTextFilter{}
	case t.Rollup != nil:
		u.value = &RollupFilter{}
	case t.Select != nil:
		u.value = &SelectFilter{}
	case t.Status != nil:
		u.value = &StatusFilter{}
	case t.Timestamp != nil:
		u.value = &TimestampFilter{}
	case t.And != nil:
		u.value = &AndFilter{}
	case t.Or != nil:
		u.value = &OrFilter{}
	default:
		return fmt.Errorf("unmarshal Filter: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *filterUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

type FilterList []Filter

func (a *FilterList) UnmarshalJSON(data []byte) error {
	t := []filterUnmarshaler{}
	if err := json.Unmarshal(data, &t); err != nil {
		return fmt.Errorf("unmarshaling FilterList: %w", err)
	}
	*a = make([]Filter, len(t))
	for i, u := range t {
		(*a)[i] = u.value
	}
	return nil
}

// Checkbox
type CheckboxFilter struct {
	FilterCommon
	Checkbox CheckboxFilterData `json:"checkbox"`
}

func (_ *CheckboxFilter) isFilter() {}

type CheckboxFilterData struct {
	Equals       *bool `json:"equals,omitempty"`         // Whether a checkbox property value matches the provided value exactly.  Returns or excludes all database entries with an exact value match.
	DoesNotEqual *bool `json:"does_not_equal,omitempty"` // Whether a checkbox property value differs from the provided value.   Returns or excludes all database entries with a difference in values.
}

/*
Date

For the after, before, equals, on_or_before, and on_or_after fields, if a date string with a time is provided, then the comparison is done with millisecond precision.

If no timezone is provided, then the timezone defaults to UTC.

A date filter condition can be used to limit date property value types and the timestamp property types created_time and last_edited_time.
*/
type DateFilter struct {
	FilterCommon
	Date DateFilterData `json:"date"`
}

func (_ *DateFilter) isFilter() {}

type DateFilterData struct {
	After      ISO8601String `json:"after,omitempty"`        // The value to compare the date property value against.   Returns database entries where the date property value is after the provided date.
	Before     ISO8601String `json:"before,omitempty"`       // The value to compare the date property value against.  Returns database entries where the date property value is before the provided date.
	Equals     ISO8601String `json:"equals,omitempty"`       // The value to compare the date property value against.  Returns database entries where the date property value is the provided date.
	IsEmpty    bool          `json:"is_empty,omitempty"`     // The value to compare the date property value against.  Returns database entries where the date property value contains no data.
	IsNotEmpty bool          `json:"is_not_empty,omitempty"` // The value to compare the date property value against.  Returns database entries where the date property value is not empty.
	NextMonth  *struct{}     `json:"next_month,omitempty"`   // A filter that limits the results to database entries where the date property value is within the next month.
	NextWeek   *struct{}     `json:"next_week,omitempty"`    // A filter that limits the results to database entries where the date property value is within the next week.
	NextYear   *struct{}     `json:"next_year,omitempty"`    // A filter that limits the results to database entries where the date property value is within the next year.
	OnOrAfter  ISO8601String `json:"on_or_after,omitempty"`  // The value to compare the date property value against.  Returns database entries where the date property value is on or after the provided date.
	OnOrBefore ISO8601String `json:"on_or_before,omitempty"` // The value to compare the date property value against.   Returns database entries where the date property value is on or before the provided date.
	PastMonth  *struct{}     `json:"past_month,omitempty"`   // A filter that limits the results to database entries where the date property value is within the past month.
	PastWeek   *struct{}     `json:"past_week,omitempty"`    // A filter that limits the results to database entries where the date property value is within the past week.
	PastYear   *struct{}     `json:"past_year,omitempty"`    // A filter that limits the results to database entries where the date property value is within the past year.
	ThisWeek   *struct{}     `json:"this_week,omitempty"`    // A filter that limits the results to database entries where the date property value is this week.
}

// Files
type FilesFilter struct {
	FilterCommon
	Files FilesFilterData `json:"files"`
}

func (_ *FilesFilter) isFilter() {}

type FilesFilterData struct {
	IsEmpty    bool `json:"is_empty,omitempty"`     // Whether the files property value does not contain any data.  Returns all database entries with an empty files property value.
	IsNotEmpty bool `json:"is_not_empty,omitempty"` // Whether the files property value contains data.   Returns all entries with a populated files property value.
}

/*
Formula

The primary field of the formula filter condition object matches the type of the formulaâ€™s result. For example, to filter a formula property that computes a checkbox, use a formula filter condition object with a checkbox field containing a checkbox filter condition as its value.
*/
type FormulaFilter struct {
	FilterCommon
	Formula FormulaFilterData `json:"formula"`
}

func (_ *FormulaFilter) isFilter() {}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *FormulaFilter) UnmarshalJSON(data []byte) error {
	type Alias FormulaFilter
	t := &struct {
		*Alias
		Formula formulaFilterDataUnmarshaler `json:"formula"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling FormulaFilter: %w", err)
	}
	o.Formula = t.Formula.value
	return nil
}

type FormulaFilterData interface {
	isFormulaFilterData()
}

type formulaFilterDataUnmarshaler struct {
	value FormulaFilterData
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "" field of the message.
*/
func (u *formulaFilterDataUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	t := struct {
		Checkbox json.RawMessage `json:"checkbox"`
		Date     json.RawMessage `json:"date"`
		Number   json.RawMessage `json:"number"`
		String   json.RawMessage `json:"string"`
	}{}
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	switch {
	case t.Checkbox != nil:
		u.value = &CheckboxFormulaFilterData{}
	case t.Date != nil:
		u.value = &DateFormulaFilterData{}
	case t.Number != nil:
		u.value = &NumberFormulaFilterData{}
	case t.String != nil:
		u.value = &StringFormulaFilterData{}
	default:
		return fmt.Errorf("unmarshal FormulaFilterData: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *formulaFilterDataUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

/*
A checkbox filter condition to compare the formula result against.

Returns database entries where the formula result matches the provided condition.
*/
type CheckboxFormulaFilterData struct {
	Checkbox CheckboxFilterData `json:"checkbox"` // A checkbox filter condition to compare the formula result against.   Returns database entries where the formula result matches the provided condition.
}

func (_ *CheckboxFormulaFilterData) isFormulaFilterData() {}

/*
A date filter condition to compare the formula result against.

Returns database entries where the formula result matches the provided condition.
*/
type DateFormulaFilterData struct {
	Date DateFilterData `json:"date"` // A date filter condition to compare the formula result against.   Returns database entries where the formula result matches the provided condition.
}

func (_ *DateFormulaFilterData) isFormulaFilterData() {}

/*
A number filter condition to compare the formula result against.

Returns database entries where the formula result matches the provided condition.
*/
type NumberFormulaFilterData struct {
	Number NumberFilterData `json:"number"` // A number filter condition to compare the formula result against.   Returns database entries where the formula result matches the provided condition.
}

func (_ *NumberFormulaFilterData) isFormulaFilterData() {}

/*
A rich text filter condition to compare the formula result against.

Returns database entries where the formula result matches the provided condition.
*/
type StringFormulaFilterData struct {
	String RichTextFilterData `json:"string"` // A rich text filter condition to compare the formula result against.   Returns database entries where the formula result matches the provided condition.
}

func (_ *StringFormulaFilterData) isFormulaFilterData() {}

// Multi-select
type MultiSelectFilter struct {
	FilterCommon
	MultiSelect MultiSelectFilterData `json:"multi_select"`
}

func (_ *MultiSelectFilter) isFilter() {}

type MultiSelectFilterData struct {
	Contains       string `json:"contains,omitempty"`         // The value to compare the multi-select property value against.   Returns database entries where the multi-select value contains the provided string.
	DoesNotContain string `json:"does_not_contain,omitempty"` // The value to the multi-select property value against.   Returns database entries where the multi-select value does not contain the provided string.
	IsEmpty        bool   `json:"is_empty,omitempty"`         // Whether the multi-select property value is empty.  Returns database entries where the multi-select value does not contain any data.
	IsNotEmpty     bool   `json:"is_not_empty,omitempty"`     // Whether the multi-select property value is not empty.  Returns database entries where the multi-select value does contains data.
}

// Number
type NumberFilter struct {
	FilterCommon
	Number NumberFilterData `json:"number"`
}

func (_ *NumberFilter) isFilter() {}

type NumberFilterData struct {
	DoesNotEqual         *float64 `json:"does_not_equal,omitempty"`           // The number to compare the number property value against.   Returns database entries where the number property value differs from the provided number.
	Equals               *float64 `json:"equals,omitempty"`                   // The number to compare the number property value against.   Returns database entries where the number property value is the same as the provided number.
	GreaterThan          *float64 `json:"greater_than,omitempty"`             // The number to compare the number property value against.   Returns database entries where the number property value exceeds the provided number.
	GreaterThanOrEqualTo *float64 `json:"greater_than_or_equal_to,omitempty"` // The number to compare the number property value against.   Returns database entries where the number property value is equal to or exceeds the provided number.
	IsEmpty              bool     `json:"is_empty,omitempty"`                 // Whether the number property value is empty.   Returns database entries where the number property value does not contain any data.
	IsNotEmpty           bool     `json:"is_not_empty,omitempty"`             // Whether the number property value is not empty.   Returns database entries where the number property value contains data.
	LessThan             *float64 `json:"less_than,omitempty"`                // The number to compare the number property value against.   Returns database entries where the page property value is less than the provided number.
	LessThanOrEqualTo    *float64 `json:"less_than_or_equal_to,omitempty"`    // The number to compare the number property value against.   Returns database entries where the page property value is equal to or is less than the provided number.
}

/*
People

You can apply a people filter condition to people, created_by, and last_edited_by database property types.
*/
type PeopleFilter struct {
	FilterCommon
	People PeopleFilterData `json:"people"`
}

func (_ *PeopleFilter) isFilter() {}

type PeopleFilterData struct {
	Contains       *uuid.UUID `json:"contains,omitempty"`         // The value to compare the people property value against.   Returns database entries where the people property value contains the provided string.
	DoesNotContain *uuid.UUID `json:"does_not_contain,omitempty"` // The value to compare the people property value against.  Returns database entries where the people property value does not contain the provided string.
	IsEmpty        bool       `json:"is_empty,omitempty"`         // Whether the people property value does not contain any data.   Returns database entries where the people property value does not contain any data.
	IsNotEmpty     bool       `json:"is_not_empty,omitempty"`     // Whether the people property value contains data.   Returns database entries where the people property value is not empty.
}

// Relation
type RelationFilter struct {
	FilterCommon
	Relation RelationFilterData `json:"relation"`
}

func (_ *RelationFilter) isFilter() {}

type RelationFilterData struct {
	Contains       *uuid.UUID `json:"contains,omitempty"`         // The value to compare the relation property value against.   Returns database entries where the relation property value contains the provided string.
	DoesNotContain *uuid.UUID `json:"does_not_contain,omitempty"` // The value to compare the relation property value against.   Returns entries where the relation property value does not contain the provided string.
	IsEmpty        bool       `json:"is_empty,omitempty"`         // Whether the relation property value does not contain data.   Returns database entries where the relation property value does not contain any data.
	IsNotEmpty     bool       `json:"is_not_empty,omitempty"`     // Whether the relation property value contains data.   Returns database entries where the property value is not empty.
}

// Rich text
type RichTextFilter struct {
	FilterCommon
	RichText RichTextFilterData `json:"rich_text"`
}

func (_ *RichTextFilter) isFilter() {}

type RichTextFilterData struct {
	Contains       string `json:"contains,omitempty"`         // The string to compare the text property value against.  Returns database entries with a text property value that includes the provided string.
	DoesNotContain string `json:"does_not_contain,omitempty"` // The string to compare the text property value against.  Returns database entries with a text property value that does not include the provided string.
	DoesNotEqual   string `json:"does_not_equal,omitempty"`   // The string to compare the text property value against.  Returns database entries with a text property value that does not match the provided string.
	EndsWith       string `json:"ends_with,omitempty"`        // The string to compare the text property value against.  Returns database entries with a text property value that ends with the provided string.
	Equals         string `json:"equals,omitempty"`           // The string to compare the text property value against.  Returns database entries with a text property value that matches the provided string.
	IsEmpty        bool   `json:"is_empty,omitempty"`         // Whether the text property value does not contain any data.   Returns database entries with a text property value that is empty.
	IsNotEmpty     bool   `json:"is_not_empty,omitempty"`     // Whether the text property value contains any data.   Returns database entries with a text property value that contains data.
	StartsWith     string `json:"starts_with,omitempty"`      // The string to compare the text property value against.  Returns database entries with a text property value that starts with the provided string.
}

// Rollup
type RollupFilter struct {
	FilterCommon
	Rollup RollupFilterData `json:"rollup"`
}

func (_ *RollupFilter) isFilter() {}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *RollupFilter) UnmarshalJSON(data []byte) error {
	type Alias RollupFilter
	t := &struct {
		*Alias
		Rollup rollupFilterDataUnmarshaler `json:"rollup"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling RollupFilter: %w", err)
	}
	o.Rollup = t.Rollup.value
	return nil
}

// A rollup database property can evaluate to an array, date, or number value. The filter condition for the rollup property contains a rollup key and a corresponding object value that depends on the computed value type.
type RollupFilterData interface {
	isRollupFilterData()
}

type rollupFilterDataUnmarshaler struct {
	value RollupFilterData
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "" field of the message.
*/
func (u *rollupFilterDataUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	t := struct {
		Any    json.RawMessage `json:"any"`
		Every  json.RawMessage `json:"every"`
		None   json.RawMessage `json:"none"`
		Date   json.RawMessage `json:"date"`
		Number json.RawMessage `json:"number"`
	}{}
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	switch {
	case t.Any != nil:
		u.value = &AnyRollupFilterData{}
	case t.Every != nil:
		u.value = &EveryRollupFilterData{}
	case t.None != nil:
		u.value = &NoneRollupFilterData{}
	case t.Date != nil:
		u.value = &DateRollupFilterData{}
	case t.Number != nil:
		u.value = &NumberRollupFilterData{}
	default:
		return fmt.Errorf("unmarshal RollupFilterData: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *rollupFilterDataUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

/*
The value to compare each rollup property value against. Can be a filter condition for any other type.

Returns database entries where the rollup property value matches the provided criteria.
*/
type AnyRollupFilterData struct {
	Any Filter `json:"any"` // The value to compare each rollup property value against. Can be a filter condition for any other type.   Returns database entries where the rollup property value matches the provided criteria.
}

func (_ *AnyRollupFilterData) isRollupFilterData() {}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *AnyRollupFilterData) UnmarshalJSON(data []byte) error {
	type Alias AnyRollupFilterData
	t := &struct {
		*Alias
		Any filterUnmarshaler `json:"any"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling AnyRollupFilterData: %w", err)
	}
	o.Any = t.Any.value
	return nil
}

/*
The value to compare each rollup property value against. Can be a filter condition for any other type.

Returns database entries where every rollup property value matches the provided criteria.
*/
type EveryRollupFilterData struct {
	Every Filter `json:"every"` // The value to compare each rollup property value against. Can be a filter condition for any other type.   Returns database entries where every rollup property value matches the provided criteria.
}

func (_ *EveryRollupFilterData) isRollupFilterData() {}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *EveryRollupFilterData) UnmarshalJSON(data []byte) error {
	type Alias EveryRollupFilterData
	t := &struct {
		*Alias
		Every filterUnmarshaler `json:"every"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling EveryRollupFilterData: %w", err)
	}
	o.Every = t.Every.value
	return nil
}

/*
The value to compare each rollup property value against. Can be a filter condition for any other type.

Returns database entries where no rollup property value matches the provided criteria.
*/
type NoneRollupFilterData struct {
	None Filter `json:"none"` // The value to compare each rollup property value against. Can be a filter condition for any other type.   Returns database entries where no rollup property value matches the provided criteria.
}

func (_ *NoneRollupFilterData) isRollupFilterData() {}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *NoneRollupFilterData) UnmarshalJSON(data []byte) error {
	type Alias NoneRollupFilterData
	t := &struct {
		*Alias
		None filterUnmarshaler `json:"none"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling NoneRollupFilterData: %w", err)
	}
	o.None = t.None.value
	return nil
}

/*
Filter conditions for date rollup values

A rollup value is stored as a date only if the "Earliest date", "Latest date", or "Date range" computation is selected for the property in the Notion UI.
*/
type DateRollupFilterData struct {
	Date DateFilterData `json:"date"` // A date filter condition to compare the rollup value against.   Returns database entries where the rollup value matches the provided condition.
}

func (_ *DateRollupFilterData) isRollupFilterData() {}

// Filter conditions for number rollup values
type NumberRollupFilterData struct {
	Number NumberFilterData `json:"number"` // A number filter condition to compare the rollup value against.   Returns database entries where the rollup value matches the provided condition.
}

func (_ *NumberRollupFilterData) isRollupFilterData() {}

// Select
type SelectFilter struct {
	FilterCommon
	Select SelectFilterData `json:"select"`
}

func (_ *SelectFilter) isFilter() {}

type SelectFilterData struct {
	Equals       string `json:"equals,omitempty"`         // The string to compare the select property value against.  Returns database entries where the select property value matches the provided string.
	DoesNotEqual string `json:"does_not_equal,omitempty"` // The string to compare the select property value against.  Returns database entries where the select property value does not match the provided string.
	IsEmpty      bool   `json:"is_empty,omitempty"`       // Whether the select property value does not contain data.  Returns database entries where the select property value is empty.
	IsNotEmpty   bool   `json:"is_not_empty,omitempty"`   // Whether the select property value contains data.  Returns database entries where the select property value is not empty.
}

// Status
type StatusFilter struct {
	FilterCommon
	Status StatusFilterData `json:"status"`
}

func (_ *StatusFilter) isFilter() {}

type StatusFilterData struct {
	Equals       string `json:"equals,omitempty"`         // The string to compare the status property value against.  Returns database entries where the status property value matches the provided string.
	DoesNotEqual string `json:"does_not_equal,omitempty"` // The string to compare the status property value against.  Returns database entries where the status property value does not match the provided string.
	IsEmpty      bool   `json:"is_empty,omitempty"`       // Whether the status property value does not contain data.  Returns database entries where the status property value is empty.
	IsNotEmpty   bool   `json:"is_not_empty,omitempty"`   // Whether the status property value contains data.  Returns database entries where the status property value is not empty.
}

/*
Timestamp

Use a timestamp filter condition to filter results based on created_time or last_edited_time values.

The timestamp filter condition does not require a property name. The API throws an error if you provide one.
*/
type TimestampFilter struct {
	FilterCommon
	Timestamp      string          `json:"timestamp"`                  // A constant string representing the type of timestamp to use as a filter.
	CreatedTime    *DateFilterData `json:"created_time,omitempty"`     // A date filter condition used to filter the specified timestamp.
	LastEditedTime *DateFilterData `json:"last_edited_time,omitempty"` // A date filter condition used to filter the specified timestamp.
}

func (_ *TimestampFilter) isFilter() {}

/*
An array of filter objects or compound filter conditions.

Returns database entries that match all of the provided filter conditions.
*/
type AndFilter struct {
	FilterCommon
	And FilterList `json:"and"` // An array of filter objects or compound filter conditions.  Returns database entries that match all of the provided filter conditions.
}

func (_ *AndFilter) isFilter() {}

/*
An array of filter objects or compound filter conditions.

Returns database entries that match any of the provided filter conditions
*/
type OrFilter struct {
	FilterCommon
	Or FilterList `json:"or"` // An array of filter objects or compound filter conditions.  Returns database entries that match any of the provided filter conditions
}

func (_ *OrFilter) isFilter() {}
