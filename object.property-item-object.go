package notion

import (
	"encoding/json"
	"fmt"
	uuid "github.com/google/uuid"
	nullv4 "gopkg.in/guregu/null.v4"
)

// Code generated by notion.doc2api; DO NOT EDIT.
// https://developers.notion.com/reference/property-item-object

/*
A property_item object describes the identifier, type, and value of a page property. It's returned from the Retrieve a page property item
*/
type PropertyItem interface {
	isPropertyItem()
	isPropertyItemOrPropertyItemPagination()
	GetObject() alwaysPropertyItem
	GetId() string
}

/*

Each page property item object contains the following keys. In addition, it will contain a key corresponding with the value of type. The value is an object containing type-specific data. The type-specific data are described in the sections below.
*/
type propertyItemCommon struct {
	Object alwaysPropertyItem `json:"object"` // Always "property_item".
	Id     string             `json:"id"`     // Underlying identifier for the property. This identifier is guaranteed to remain constant when the property name changes. It may be a UUID, but is often a short random string.  The id may be used in place of name when creating or updating pages.
}

func (c *propertyItemCommon) GetObject() alwaysPropertyItem {
	return c.Object
}
func (c *propertyItemCommon) GetId() string {
	return c.Id
}

type propertyItemUnmarshaler struct {
	value PropertyItem
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "type" field of the message.
*/
func (u *propertyItemUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	switch string(getType(data)) {
	case "\"title\"":
		u.value = &TitlePropertyItem{}
	case "\"rich_text\"":
		u.value = &RichTextPropertyItem{}
	case "\"number\"":
		u.value = &NumberPropertyItem{}
	case "\"select\"":
		u.value = &SelectPropertyItem{}
	case "\"multi_select\"":
		u.value = &MultiSelectPropertyItem{}
	case "\"date\"":
		u.value = &DatePropertyItem{}
	case "\"formula\"":
		u.value = &FormulaPropertyItem{}
	case "\"relation\"":
		u.value = &RelationPropertyItem{}
	case "\"rollup\"":
		u.value = &RollupPropertyItem{}
	case "\"people\"":
		u.value = &PeoplePropertyItem{}
	case "\"files\"":
		u.value = &FilesPropertyItem{}
	case "\"checkbox\"":
		u.value = &CheckboxPropertyItem{}
	case "\"url\"":
		u.value = &UrlPropertyItem{}
	case "\"email\"":
		u.value = &EmailPropertyItem{}
	case "\"phone_number\"":
		u.value = &PhoneNumberPropertyItem{}
	case "\"created_time\"":
		u.value = &CreatedTimePropertyItem{}
	case "\"created_by\"":
		u.value = &CreatedByPropertyItem{}
	case "\"last_edited_time\"":
		u.value = &LastEditedTimePropertyItem{}
	case "\"last_edited_by\"":
		u.value = &LastEditedByPropertyItem{}
	default:
		return fmt.Errorf("unmarshaling PropertyItem: data has unknown type field: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *propertyItemUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

type PropertyItems []PropertyItem

func (a *PropertyItems) UnmarshalJSON(data []byte) error {
	t := []propertyItemUnmarshaler{}
	if err := json.Unmarshal(data, &t); err != nil {
		return fmt.Errorf("unmarshaling PropertyItems: %w", err)
	}
	*a = make([]PropertyItem, len(t))
	for i, u := range t {
		(*a)[i] = u.value
	}
	return nil
}

/*

The title, rich_text, relation and people property items of are returned as a paginated list object of individual property_item objects in the results. An abridged set of the the properties found in the list object are found below, see the Pagination documentation for additional information.
*/
type PaginatedPropertyInfo interface {
	isPaginatedPropertyInfo()
	GetId() string
	GetType() string
	GetNextUrl() *string
}
type paginatedPropertyInfoCommon struct {
	Id      string  `json:"id"`
	Type    string  `json:"type"`
	NextUrl *string `json:"next_url"` // The URL the user can request to get the next page of results.
}

func (c *paginatedPropertyInfoCommon) GetId() string {
	return c.Id
}
func (c *paginatedPropertyInfoCommon) GetType() string {
	return c.Type
}
func (c *paginatedPropertyInfoCommon) GetNextUrl() *string {
	return c.NextUrl
}

type paginatedPropertyInfoUnmarshaler struct {
	value PaginatedPropertyInfo
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "type" field of the message.
*/
func (u *paginatedPropertyInfoUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	switch string(getType(data)) {
	case "\"title\"":
		u.value = &TitlePaginatedPropertyInfo{}
	case "\"rich_text\"":
		u.value = &RichTextPaginatedPropertyInfo{}
	case "\"relation\"":
		u.value = &RelationPaginatedPropertyInfo{}
	case "\"people\"":
		u.value = &PeoplePaginatedPropertyInfo{}
	default:
		return fmt.Errorf("unmarshaling PaginatedPropertyInfo: data has unknown type field: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *paginatedPropertyInfoUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

type TitlePaginatedPropertyInfo struct {
	paginatedPropertyInfoCommon
	Type  alwaysTitle `json:"type"`
	Title struct{}    `json:"title"`
}

func (_ *TitlePaginatedPropertyInfo) isPaginatedPropertyInfo() {}

type RichTextPaginatedPropertyInfo struct {
	paginatedPropertyInfoCommon
	Type     alwaysRichText `json:"type"`
	RichText struct{}       `json:"rich_text"`
}

func (_ *RichTextPaginatedPropertyInfo) isPaginatedPropertyInfo() {}

type RelationPaginatedPropertyInfo struct {
	paginatedPropertyInfoCommon
	Type     alwaysRelation `json:"type"`
	Relation struct{}       `json:"relation"`
}

func (_ *RelationPaginatedPropertyInfo) isPaginatedPropertyInfo() {}

type PeoplePaginatedPropertyInfo struct {
	paginatedPropertyInfoCommon
	Type   alwaysPeople `json:"type"`
	People struct{}     `json:"people"`
}

func (_ *PeoplePaginatedPropertyInfo) isPaginatedPropertyInfo() {}

// Title property values
type TitlePropertyItem struct {
	propertyItemCommon
	Type  alwaysTitle `json:"type"`
	Title RichText    `json:"title"` //  Title property value objects contain an array of rich text objects within the title property.
}

func (_ *TitlePropertyItem) isPropertyItem()                         {}
func (_ *TitlePropertyItem) isPropertyItemOrPropertyItemPagination() {}
func (o *TitlePropertyItem) UnmarshalJSON(data []byte) error {
	type Alias TitlePropertyItem
	t := &struct {
		*Alias
		Title richTextUnmarshaler `json:"title"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling TitlePropertyItem: %w", err)
	}
	o.Title = t.Title.value
	return nil
}

// Rich Text property values
type RichTextPropertyItem struct {
	propertyItemCommon
	Type     alwaysRichText `json:"type"`
	RichText RichText       `json:"rich_text"` //  Rich Text property value objects contain an array of rich text objects within the rich_text property.
}

func (_ *RichTextPropertyItem) isPropertyItem()                         {}
func (_ *RichTextPropertyItem) isPropertyItemOrPropertyItemPagination() {}
func (o *RichTextPropertyItem) UnmarshalJSON(data []byte) error {
	type Alias RichTextPropertyItem
	t := &struct {
		*Alias
		RichText richTextUnmarshaler `json:"rich_text"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling RichTextPropertyItem: %w", err)
	}
	o.RichText = t.RichText.value
	return nil
}

// Number property values
type NumberPropertyItem struct {
	propertyItemCommon
	Type   alwaysNumber `json:"type"`
	Number float64      `json:"number"` //  Number property value objects contain a number within the number property.
}

func (_ *NumberPropertyItem) isPropertyItem()                         {}
func (_ *NumberPropertyItem) isPropertyItemOrPropertyItemPagination() {}

// Select property values
type SelectPropertyItem struct {
	propertyItemCommon
	Type   alwaysSelect           `json:"type"`
	Select SelectPropertyItemData `json:"select"` //  Select property value objects contain the following data within the select property:
}

func (_ *SelectPropertyItem) isPropertyItem()                         {}
func (_ *SelectPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*

Select property value objects contain the following data within the select property:
*/
type SelectPropertyItemData struct {
	Id    uuid.UUID `json:"id"`    // ID of the option.  When updating a select property, you can use either name or id.
	Name  string    `json:"name"`  // Name of the option as it appears in Notion.  If the select database property does not yet have an option by that name, it will be added to the database schema if the integration also has write access to the parent database.  Note: Commas (",") are not valid for select values.
	Color string    `json:"color"` // Color of the option. Possible values are: "default", "gray", "brown", "red", "orange", "yellow", "green", "blue", "purple", "pink". Defaults to "default".  Not currently editable.
}

// Multi-select property values
type MultiSelectPropertyItem struct {
	propertyItemCommon
	Type        alwaysMultiSelect             `json:"type"`
	MultiSelect []MultiSelectPropertyItemData `json:"multi_select"` //  Multi-select property value objects contain an array of multi-select option values within the multi_select property.
}

func (_ *MultiSelectPropertyItem) isPropertyItem()                         {}
func (_ *MultiSelectPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*

Multi-select property value objects contain an array of multi-select option values within the multi_select property.
*/
type MultiSelectPropertyItemData struct {
	Id    uuid.UUID `json:"id"`    // ID of the option.  When updating a multi-select property, you can use either name or id.
	Name  string    `json:"name"`  // Name of the option as it appears in Notion.  If the multi-select database property does not yet have an option by that name, it will be added to the database schema if the integration also has write access to the parent database.  Note: Commas (",") are not valid for select values.
	Color string    `json:"color"` // Color of the option. Possible values are: "default", "gray", "brown", "red", "orange", "yellow", "green", "blue", "purple", "pink". Defaults to "default".  Not currently editable.
}

// Date property values
type DatePropertyItem struct {
	propertyItemCommon
	Type alwaysDate           `json:"type"`
	Date DatePropertyItemData `json:"date"`
}

func (_ *DatePropertyItem) isPropertyItem()                         {}
func (_ *DatePropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*

Date property value objects contain the following data within the date property:
*/
type DatePropertyItemData struct {
	Start    ISO8601String  `json:"start"`     // An ISO 8601 format date, with optional time.
	End      *ISO8601String `json:"end"`       // An ISO 8601 formatted date, with optional time. Represents the end of a date range.  If null, this property's date value is not a range.
	TimeZone nullv4.String  `json:"time_zone"` // Time zone information for start and end. Possible values are extracted from the IANA database and they are based on the time zones from Moment.js.  When time zone is provided, start and end should not have any UTC offset. In addition, when time zone  is provided, start and end cannot be dates without time information.  If null, time zone information will be contained in UTC offsets in start and end.
}

// Formula property values
type FormulaPropertyItem struct {
	propertyItemCommon
	Type    alwaysFormula `json:"type"`
	Formula Formula       `json:"formula"` //  Formula property value objects represent the result of evaluating a formula described in the  database's properties. These objects contain a type key and a key corresponding with the value of type. The value is an object containing type-specific data. The type-specific data are described in the sections below.
}

func (_ *FormulaPropertyItem) isPropertyItem()                         {}
func (_ *FormulaPropertyItem) isPropertyItemOrPropertyItemPagination() {}

// Relation property values
type RelationPropertyItem struct {
	propertyItemCommon
	Type     alwaysRelation `json:"type"`
	Relation PageReference  `json:"relation"` //  Relation property value objects contain an array of relation property items with page references within the relation property. A page reference is an object with an id property which is a string value (UUIDv4) corresponding to a page ID in another database.
}

func (_ *RelationPropertyItem) isPropertyItem()                         {}
func (_ *RelationPropertyItem) isPropertyItemOrPropertyItemPagination() {}

// Rollup property values
type RollupPropertyItem struct {
	propertyItemCommon
	Type   alwaysRollup `json:"type"`
	Rollup Rollup       `json:"rollup"` //  Rollup property value objects represent the result of evaluating a rollup described in the  database's properties. The property is returned as a list object of type property_item with a list of relation items used to computed the rollup under results.   A rollup property item is also returned under the property_type key that describes the rollup aggregation and computed result.   In order to avoid timeouts, if the rollup has a with a large number of aggregations or properties the endpoint returns a next_cursor value that is used to determinate the aggregation value so far for the subset of relations that have been paginated through.   Once has_more is false, then the final rollup value is returned.  See the Pagination documentation for more information on pagination in the Notion API.   Computing the values of following aggregations are not supported. Instead the endpoint returns a list of property_item objects for the rollup: * show_unique (Show unique values) * unique (Count unique values) * median(Median)
}

func (_ *RollupPropertyItem) isPropertyItem()                         {}
func (_ *RollupPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
People property values
People property value objects contain an array of user objects within the people property.
*/
type PeoplePropertyItem struct {
	propertyItemCommon
	Type   alwaysPeople `json:"type"`
	People User         `json:"people"`
}

func (_ *PeoplePropertyItem) isPropertyItem()                         {}
func (_ *PeoplePropertyItem) isPropertyItemOrPropertyItemPagination() {}
func (o *PeoplePropertyItem) UnmarshalJSON(data []byte) error {
	type Alias PeoplePropertyItem
	t := &struct {
		*Alias
		People userUnmarshaler `json:"people"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling PeoplePropertyItem: %w", err)
	}
	o.People = t.People.value
	return nil
}

/*
Files property values
File property value objects contain an array of file references within the files property. A file reference is an object with a File Object and name property, with a string value corresponding to a filename of the original file upload (i.e. "Whole_Earth_Catalog.jpg").
*/
type FilesPropertyItem struct {
	propertyItemCommon
	Type  alwaysFiles `json:"type"`
	Files Files       `json:"files"`
}

func (_ *FilesPropertyItem) isPropertyItem()                         {}
func (_ *FilesPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
Checkbox property values
Checkbox property value objects contain a boolean within the checkbox property.
*/
type CheckboxPropertyItem struct {
	propertyItemCommon
	Type     alwaysCheckbox `json:"type"`
	Checkbox bool           `json:"checkbox"`
}

func (_ *CheckboxPropertyItem) isPropertyItem()                         {}
func (_ *CheckboxPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
URL property values
URL property value objects contain a non-empty string within the url property. The string describes a web address (i.e. "http://worrydream.com/EarlyHistoryOfSmalltalk/").
*/
type UrlPropertyItem struct {
	propertyItemCommon
	Type alwaysUrl     `json:"type"`
	Url  nullv4.String `json:"url"`
}

func (_ *UrlPropertyItem) isPropertyItem()                         {}
func (_ *UrlPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
Email property values
Email property value objects contain a string within the email property. The string describes an email address (i.e. "hello@example.org").
*/
type EmailPropertyItem struct {
	propertyItemCommon
	Type  alwaysEmail   `json:"type"`
	Email nullv4.String `json:"email"`
}

func (_ *EmailPropertyItem) isPropertyItem()                         {}
func (_ *EmailPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
Phone number property values
Phone number property value objects contain a string within the phone_number property. No structure is enforced.
*/
type PhoneNumberPropertyItem struct {
	propertyItemCommon
	Type        alwaysPhoneNumber `json:"type"`
	PhoneNumber nullv4.String     `json:"phone_number"`
}

func (_ *PhoneNumberPropertyItem) isPropertyItem()                         {}
func (_ *PhoneNumberPropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
Created time property values
Created time property value objects contain a string within the created_time property. The string contains the date and time when this page was created. It is formatted as an ISO 8601 date time string (i.e. "2020-03-17T19:10:04.968Z").
*/
type CreatedTimePropertyItem struct {
	propertyItemCommon
	Type        alwaysCreatedTime `json:"type"`
	CreatedTime ISO8601String     `json:"created_time"`
}

func (_ *CreatedTimePropertyItem) isPropertyItem()                         {}
func (_ *CreatedTimePropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
Created by property values
Created by property value objects contain a user object within the created_by property. The user object describes the user who created this page.
*/
type CreatedByPropertyItem struct {
	propertyItemCommon
	Type      alwaysCreatedBy `json:"type"`
	CreatedBy User            `json:"created_by"`
}

func (_ *CreatedByPropertyItem) isPropertyItem()                         {}
func (_ *CreatedByPropertyItem) isPropertyItemOrPropertyItemPagination() {}
func (o *CreatedByPropertyItem) UnmarshalJSON(data []byte) error {
	type Alias CreatedByPropertyItem
	t := &struct {
		*Alias
		CreatedBy userUnmarshaler `json:"created_by"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling CreatedByPropertyItem: %w", err)
	}
	o.CreatedBy = t.CreatedBy.value
	return nil
}

/*
Last edited time property values
Last edited time property value objects contain a string within the last_edited_time property. The string contains the date and time when this page was last updated. It is formatted as an ISO 8601 date time string (i.e. "2020-03-17T19:10:04.968Z").
*/
type LastEditedTimePropertyItem struct {
	propertyItemCommon
	Type           alwaysLastEditedTime `json:"type"`
	LastEditedTime ISO8601String        `json:"last_edited_time"`
}

func (_ *LastEditedTimePropertyItem) isPropertyItem()                         {}
func (_ *LastEditedTimePropertyItem) isPropertyItemOrPropertyItemPagination() {}

/*
Last edited by property values
Last edited by property value objects contain a user object within the last_edited_by property. The user object describes the user who last updated this page.
*/
type LastEditedByPropertyItem struct {
	propertyItemCommon
	Type         alwaysLastEditedBy `json:"type"`
	LastEditedBy User               `json:"last_edited_by"`
}

func (_ *LastEditedByPropertyItem) isPropertyItem()                         {}
func (_ *LastEditedByPropertyItem) isPropertyItemOrPropertyItemPagination() {}
func (o *LastEditedByPropertyItem) UnmarshalJSON(data []byte) error {
	type Alias LastEditedByPropertyItem
	t := &struct {
		*Alias
		LastEditedBy userUnmarshaler `json:"last_edited_by"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling LastEditedByPropertyItem: %w", err)
	}
	o.LastEditedBy = t.LastEditedBy.value
	return nil
}
