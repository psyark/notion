package notion

import (
	"encoding/json"
	"fmt"
	nullv4 "gopkg.in/guregu/null.v4"
	"reflect"
)

// Code generated by notion.doc2api; DO NOT EDIT.
// https://developers.notion.com/reference/property-value-object

/*
A property value defines the identifier, type, and value of a page property in a page object. It's used when retrieving and updating pages, ex: Create and Update pages.

Property values in the page object have a 25 page reference limit
Any property value that has other pages in its value will only use the first 25 page references. Use the [Retrieve a page property](https://developers.notion.com/reference/retrieve-a-page-property) endpoint to paginate through the full value.
Each page property value object contains the following keys. In addition, it contains a key corresponding with the value of type. The value is an object containing type-specific data. The type-specific data are described in the sections below.
*/
type PropertyValue interface {
	isPropertyValue()
	get() reflect.Value // for binding
	set(reflect.Value)  // for binding
	GetId() string
}
type PropertyValueCommon struct {
	Id string `json:"id,omitempty"` // Underlying identifier for the property. This identifier is guaranteed to remain constant when the property name changes. It may be a UUID, but is often a short random string.  The id may be used in place of name when creating or updating pages.
}

func (c *PropertyValueCommon) GetId() string {
	return c.Id
}

type propertyValueUnmarshaler struct {
	value PropertyValue
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "type" field of the message.
*/
func (u *propertyValueUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	t := struct {
		Title          json.RawMessage `json:"title"`
		RichText       json.RawMessage `json:"rich_text"`
		Number         json.RawMessage `json:"number"`
		Select         json.RawMessage `json:"select"`
		Status         json.RawMessage `json:"status"`
		MultiSelect    json.RawMessage `json:"multi_select"`
		Date           json.RawMessage `json:"date"`
		Formula        json.RawMessage `json:"formula"`
		Relation       json.RawMessage `json:"relation"`
		Rollup         json.RawMessage `json:"rollup"`
		People         json.RawMessage `json:"people"`
		Files          json.RawMessage `json:"files"`
		Checkbox       json.RawMessage `json:"checkbox"`
		Url            json.RawMessage `json:"url"`
		Email          json.RawMessage `json:"email"`
		PhoneNumber    json.RawMessage `json:"phone_number"`
		CreatedTime    json.RawMessage `json:"created_time"`
		CreatedBy      json.RawMessage `json:"created_by"`
		LastEditedTime json.RawMessage `json:"last_edited_time"`
		LastEditedBy   json.RawMessage `json:"last_edited_by"`
	}{}
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	switch {
	case t.Title != nil:
		u.value = &TitlePropertyValue{}
	case t.RichText != nil:
		u.value = &RichTextPropertyValue{}
	case t.Number != nil:
		u.value = &NumberPropertyValue{}
	case t.Select != nil:
		u.value = &SelectPropertyValue{}
	case t.Status != nil:
		u.value = &StatusPropertyValue{}
	case t.MultiSelect != nil:
		u.value = &MultiSelectPropertyValue{}
	case t.Date != nil:
		u.value = &DatePropertyValue{}
	case t.Formula != nil:
		u.value = &FormulaPropertyValue{}
	case t.Relation != nil:
		u.value = &RelationPropertyValue{}
	case t.Rollup != nil:
		u.value = &RollupPropertyValue{}
	case t.People != nil:
		u.value = &PeoplePropertyValue{}
	case t.Files != nil:
		u.value = &FilesPropertyValue{}
	case t.Checkbox != nil:
		u.value = &CheckboxPropertyValue{}
	case t.Url != nil:
		u.value = &UrlPropertyValue{}
	case t.Email != nil:
		u.value = &EmailPropertyValue{}
	case t.PhoneNumber != nil:
		u.value = &PhoneNumberPropertyValue{}
	case t.CreatedTime != nil:
		u.value = &CreatedTimePropertyValue{}
	case t.CreatedBy != nil:
		u.value = &CreatedByPropertyValue{}
	case t.LastEditedTime != nil:
		u.value = &LastEditedTimePropertyValue{}
	case t.LastEditedBy != nil:
		u.value = &LastEditedByPropertyValue{}
	default:
		return fmt.Errorf("unmarshal PropertyValue: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *propertyValueUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

type PropertyValueArray []PropertyValue

func (a *PropertyValueArray) UnmarshalJSON(data []byte) error {
	t := []propertyValueUnmarshaler{}
	if err := json.Unmarshal(data, &t); err != nil {
		return fmt.Errorf("unmarshaling PropertyValueArray: %w", err)
	}
	*a = make([]PropertyValue, len(t))
	for i, u := range t {
		(*a)[i] = u.value
	}
	return nil
}

type PropertyValueMap map[string]PropertyValue

func (m *PropertyValueMap) UnmarshalJSON(data []byte) error {
	t := map[string]propertyValueUnmarshaler{}
	if err := json.Unmarshal(data, &t); err != nil {
		return fmt.Errorf("unmarshaling PropertyValueMap: %w", err)
	}
	*m = PropertyValueMap{}
	for k, u := range t {
		(*m)[k] = u.value
	}
	return nil
}

/*
Title property values

The [Retrieve a page endpoint](https://developers.notion.com/reference/retrieve-a-page) returns a maximum of 25 inline page or person references for a `title` property. If a `title` property includes more than 25 references, then you can use the [Retrieve a page property](https://developers.notion.com/reference/retrieve-a-page-property) endpoint for the specific `title` property to get its complete list of references.
*/
type TitlePropertyValue struct {
	PropertyValueCommon
	Type  alwaysTitle   `json:"type"`
	Title RichTextArray `json:"title"` //  Title property value objects contain an array of rich text objects within the title property.
}

func (_ *TitlePropertyValue) isPropertyValue() {}

// for binding
func (o *TitlePropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Title)
}

// for binding
func (o *TitlePropertyValue) set(v reflect.Value) {
	o.Title = v.Interface().(RichTextArray)
}

/*
Rich Text property values

The [Retrieve a page endpoint](https://developers.notion.com/reference/retrieve-a-page) returns a maximum of 25 populated inline page or person references for a `rich_text` property. If a `rich_text` property includes more than 25 references, then you can use the [Retrieve a page property endpoint](https://developers.notion.com/reference/retrieve-a-page-property) for the specific `rich_text` property to get its complete list of references.
*/
type RichTextPropertyValue struct {
	PropertyValueCommon
	Type     alwaysRichText `json:"type"`
	RichText RichTextArray  `json:"rich_text"` //  Rich Text property value objects contain an array of rich text objects within the rich_text property.
}

func (_ *RichTextPropertyValue) isPropertyValue() {}

// for binding
func (o *RichTextPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.RichText)
}

// for binding
func (o *RichTextPropertyValue) set(v reflect.Value) {
	o.RichText = v.Interface().(RichTextArray)
}

// Number property values
type NumberPropertyValue struct {
	PropertyValueCommon
	Type   alwaysNumber `json:"type"`
	Number nullv4.Float `json:"number"` //  Number property value objects contain a number within the number property.
}

func (_ *NumberPropertyValue) isPropertyValue() {}

// for binding
func (o *NumberPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Number)
}

// for binding
func (o *NumberPropertyValue) set(v reflect.Value) {
	o.Number = v.Interface().(nullv4.Float)
}

// Select property values
type SelectPropertyValue struct {
	PropertyValueCommon
	Type   alwaysSelect `json:"type"`
	Select *Option      `json:"select"` //  Select property value objects contain the following data within the select property:
}

func (_ *SelectPropertyValue) isPropertyValue() {}

// for binding
func (o *SelectPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Select)
}

// for binding
func (o *SelectPropertyValue) set(v reflect.Value) {
	o.Select = v.Interface().(*Option)
}

// Status property values
type StatusPropertyValue struct {
	PropertyValueCommon
	Type   alwaysStatus `json:"type"`
	Status Option       `json:"status"` //  Status property value objects contain the following data within the status property:
}

func (_ *StatusPropertyValue) isPropertyValue() {}

// for binding
func (o *StatusPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Status)
}

// for binding
func (o *StatusPropertyValue) set(v reflect.Value) {
	o.Status = v.Interface().(Option)
}

// Multi-select property values
type MultiSelectPropertyValue struct {
	PropertyValueCommon
	Type        alwaysMultiSelect `json:"type"`
	MultiSelect []Option          `json:"multi_select"` //  Multi-select property value objects contain an array of multi-select option values within the multi_select property.
}

func (_ *MultiSelectPropertyValue) isPropertyValue() {}

// for binding
func (o *MultiSelectPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.MultiSelect)
}

// for binding
func (o *MultiSelectPropertyValue) set(v reflect.Value) {
	o.MultiSelect = v.Interface().([]Option)
}

// Date property values
type DatePropertyValue struct {
	PropertyValueCommon
	Type alwaysDate             `json:"type"`
	Date *DatePropertyValueData `json:"date"` //  Date property value objects contain the following data within the date property:
}

func (_ *DatePropertyValue) isPropertyValue() {}

// for binding
func (o *DatePropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Date)
}

// for binding
func (o *DatePropertyValue) set(v reflect.Value) {
	o.Date = v.Interface().(*DatePropertyValueData)
}

/*

Date property value objects contain the following data within the date property:
*/
type DatePropertyValueData struct {
	Start    ISO8601String  `json:"start"`     // An ISO 8601 format date, with optional time.
	End      *ISO8601String `json:"end"`       // An ISO 8601 formatted date, with optional time. Represents the end of a date range.  If null, this property's date value is not a range.
	TimeZone *string        `json:"time_zone"` // Time zone information for start and end. Possible values are extracted from the IANA database and they are based on the time zones from Moment.js.  When time zone is provided, start and end should not have any UTC offset. In addition, when time zone  is provided, start and end cannot be dates without time information.  If null, time zone information will be contained in UTC offsets in start and end.
}

/*
Formula property values
Formula property value objects represent the result of evaluating a formula described in the
database's properties. These objects contain a type key and a key corresponding with the value of type. The value of a formula cannot be updated directly.

Formula values may not match the Notion UI.
Formulas returned in page objects are subject to a 25 page reference limitation. The Retrieve a page property endpoint should be used to get an accurate formula value.
*/
type FormulaPropertyValue struct {
	PropertyValueCommon
	Type    alwaysFormula `json:"type"`
	Formula Formula       `json:"formula"`
}

func (_ *FormulaPropertyValue) isPropertyValue() {}

// for binding
func (o *FormulaPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Formula)
}

// for binding
func (o *FormulaPropertyValue) set(v reflect.Value) {
	o.Formula = v.Interface().(Formula)
}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *FormulaPropertyValue) UnmarshalJSON(data []byte) error {
	type Alias FormulaPropertyValue
	t := &struct {
		*Alias
		Formula formulaUnmarshaler `json:"formula"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling FormulaPropertyValue: %w", err)
	}
	o.Formula = t.Formula.value
	return nil
}

type Formula interface {
	isFormula()
}

type formulaUnmarshaler struct {
	value Formula
}

/*
UnmarshalJSON unmarshals a JSON message and sets the value field to the appropriate instance
according to the "type" field of the message.
*/
func (u *formulaUnmarshaler) UnmarshalJSON(data []byte) error {
	if string(data) == "null" {
		u.value = nil
		return nil
	}
	t := struct {
		String  json.RawMessage `json:"string"`
		Number  json.RawMessage `json:"number"`
		Boolean json.RawMessage `json:"boolean"`
		Date    json.RawMessage `json:"date"`
	}{}
	if err := json.Unmarshal(data, &t); err != nil {
		return err
	}
	switch {
	case t.String != nil:
		u.value = &StringFormula{}
	case t.Number != nil:
		u.value = &NumberFormula{}
	case t.Boolean != nil:
		u.value = &BooleanFormula{}
	case t.Date != nil:
		u.value = &DateFormula{}
	default:
		return fmt.Errorf("unmarshal Formula: %s", string(data))
	}
	return json.Unmarshal(data, u.value)
}

func (u *formulaUnmarshaler) MarshalJSON() ([]byte, error) {
	return json.Marshal(u.value)
}

// String formula property values
type StringFormula struct {
	Type   alwaysString  `json:"type"`
	String nullv4.String `json:"string"` //  String formula property values contain an optional string within the string property.
}

func (_ *StringFormula) isFormula() {}

// Number formula property values
type NumberFormula struct {
	Type   alwaysNumber `json:"type"`
	Number float64      `json:"number"` //  Number formula property values contain an optional number within the number property.
}

func (_ *NumberFormula) isFormula() {}

// Boolean formula property values
type BooleanFormula struct {
	Type    alwaysBoolean `json:"type"`
	Boolean bool          `json:"boolean"` //  Boolean formula property values contain a boolean within the boolean property.
}

func (_ *BooleanFormula) isFormula() {}

// Date formula property values
type DateFormula struct {
	Type alwaysDate        `json:"type"`
	Date DatePropertyValue `json:"date"` //  Date formula property values contain an optional date property value within the date property.
}

func (_ *DateFormula) isFormula() {}

/*
Relation property values
Relation property value objects contain an array of page references within the relation property. A page reference is an object with an id key and a string value (UUIDv4) corresponding to a page ID in another database.

A relation includes a has_more property in the Retrieve a page endpoint response object. The endpoint returns a maximum of 25 page references for a relation. If a relation has more than 25 references, then the has_more value for the relation in the response object is true. If a relation doesn’t exceed the limit, then has_more is false.

Note that updating a relation property value with an empty array will clear the list.
*/
type RelationPropertyValue struct {
	PropertyValueCommon
	Type     alwaysRelation  `json:"type"`
	Relation []PageReference `json:"relation"`
	HasMore  bool            `json:"has_more"`
}

func (_ *RelationPropertyValue) isPropertyValue() {}

// for binding
func (o *RelationPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Relation)
}

// for binding
func (o *RelationPropertyValue) set(v reflect.Value) {
	o.Relation = v.Interface().([]PageReference)
}

/*
Rollup property values
Rollup property value objects represent the result of evaluating a rollup described in the
database's properties. These objects contain a type key and a key corresponding with the value of type. The value of a rollup cannot be updated directly.

Rollup values may not match the Notion UI.
Rollups returned in page objects are subject to a 25 page reference limitation. The Retrieve a page property endpoint should be used to get an accurate formula value.
*/
type RollupPropertyValue struct {
	PropertyValueCommon
	Type   alwaysRollup `json:"type"`
	Rollup Rollup       `json:"rollup"`
}

func (_ *RollupPropertyValue) isPropertyValue() {}

// for binding
func (o *RollupPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Rollup)
}

// for binding
func (o *RollupPropertyValue) set(v reflect.Value) {
	o.Rollup = v.Interface().(Rollup)
}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *RollupPropertyValue) UnmarshalJSON(data []byte) error {
	type Alias RollupPropertyValue
	t := &struct {
		*Alias
		Rollup rollupUnmarshaler `json:"rollup"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling RollupPropertyValue: %w", err)
	}
	o.Rollup = t.Rollup.value
	return nil
}

/*
People property values

The [Retrieve a page](https://developers.notion.com/reference/retrieve-a-page) endpoint can’t be guaranteed to return more than 25 people per `people` page property. If a `people` page property includes more than 25 people, then you can use the [Retrieve a page property endpoint](https://developers.notion.com/reference/retrieve-a-page-property) for the specific `people` property to get a complete list of people.
*/
type PeoplePropertyValue struct {
	PropertyValueCommon
	Type   alwaysPeople `json:"type"`
	People Users        `json:"people"` //  People property value objects contain an array of user objects within the people property.
}

func (_ *PeoplePropertyValue) isPropertyValue() {}

// for binding
func (o *PeoplePropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.People)
}

// for binding
func (o *PeoplePropertyValue) set(v reflect.Value) {
	o.People = v.Interface().(Users)
}

/*
Files property values

When updating a file property, the value will be overwritten by the array of files passed.
Although we do not support uploading files, if you pass a `file` object containing a file hosted by Notion, it will remain one of the files. To remove any file, just do not pass it in the update response.
*/
type FilesPropertyValue struct {
	PropertyValueCommon
	Type  alwaysFiles `json:"type"`
	Files Files       `json:"files"` //  File property value objects contain an array of file references within the files property. A file reference is an object with a File Object and name property, with a string value corresponding to a filename of the original file upload (i.e. "Whole_Earth_Catalog.jpg").
}

func (_ *FilesPropertyValue) isPropertyValue() {}

// for binding
func (o *FilesPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Files)
}

// for binding
func (o *FilesPropertyValue) set(v reflect.Value) {
	o.Files = v.Interface().(Files)
}

// Checkbox property values
type CheckboxPropertyValue struct {
	PropertyValueCommon
	Type     alwaysCheckbox `json:"type"`
	Checkbox bool           `json:"checkbox"` //  Checkbox property value objects contain a boolean within the checkbox property.
}

func (_ *CheckboxPropertyValue) isPropertyValue() {}

// for binding
func (o *CheckboxPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Checkbox)
}

// for binding
func (o *CheckboxPropertyValue) set(v reflect.Value) {
	o.Checkbox = v.Interface().(bool)
}

// URL property values
type UrlPropertyValue struct {
	PropertyValueCommon
	Type alwaysUrl     `json:"type"`
	Url  nullv4.String `json:"url"` //  URL property value objects contain a non-empty string within the url property. The string describes a web address (i.e. "http://worrydream.com/EarlyHistoryOfSmalltalk/").
}

func (_ *UrlPropertyValue) isPropertyValue() {}

// for binding
func (o *UrlPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Url)
}

// for binding
func (o *UrlPropertyValue) set(v reflect.Value) {
	o.Url = v.Interface().(nullv4.String)
}

// Email property values
type EmailPropertyValue struct {
	PropertyValueCommon
	Type  alwaysEmail   `json:"type"`
	Email nullv4.String `json:"email"` //  Email property value objects contain a string within the email property. The string describes an email address (i.e. "hello@example.org").
}

func (_ *EmailPropertyValue) isPropertyValue() {}

// for binding
func (o *EmailPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.Email)
}

// for binding
func (o *EmailPropertyValue) set(v reflect.Value) {
	o.Email = v.Interface().(nullv4.String)
}

// Phone number property values
type PhoneNumberPropertyValue struct {
	PropertyValueCommon
	Type        alwaysPhoneNumber `json:"type"`
	PhoneNumber nullv4.String     `json:"phone_number"` //  Phone number property value objects contain a string within the phone_number property. No structure is enforced.
}

func (_ *PhoneNumberPropertyValue) isPropertyValue() {}

// for binding
func (o *PhoneNumberPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.PhoneNumber)
}

// for binding
func (o *PhoneNumberPropertyValue) set(v reflect.Value) {
	o.PhoneNumber = v.Interface().(nullv4.String)
}

// Created time property values
type CreatedTimePropertyValue struct {
	PropertyValueCommon
	Type        alwaysCreatedTime `json:"type"`
	CreatedTime ISO8601String     `json:"created_time"` //  Created time property value objects contain a string within the created_time property. The string contains the date and time when this page was created. It is formatted as an ISO 8601 date time string (i.e. "2020-03-17T19:10:04.968Z"). The value of created_time cannot be updated. See the Property Item Object to see how these values are returned.
}

func (_ *CreatedTimePropertyValue) isPropertyValue() {}

// for binding
func (o *CreatedTimePropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.CreatedTime)
}

// for binding
func (o *CreatedTimePropertyValue) set(v reflect.Value) {
	o.CreatedTime = v.Interface().(ISO8601String)
}

// Created by property values
type CreatedByPropertyValue struct {
	PropertyValueCommon
	Type      alwaysCreatedBy `json:"type"`
	CreatedBy PartialUser     `json:"created_by"` //  Created by property value objects contain a user object within the created_by property. The user object describes the user who created this page. The value of created_by cannot be updated. See the Property Item Object to see how these values are returned.
}

func (_ *CreatedByPropertyValue) isPropertyValue() {}

// for binding
func (o *CreatedByPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.CreatedBy)
}

// for binding
func (o *CreatedByPropertyValue) set(v reflect.Value) {
	o.CreatedBy = v.Interface().(PartialUser)
}

// Last edited time property values
type LastEditedTimePropertyValue struct {
	PropertyValueCommon
	Type           alwaysLastEditedTime `json:"type"`
	LastEditedTime ISO8601String        `json:"last_edited_time"` //  Last edited time property value objects contain a string within the last_edited_time property. The string contains the date and time when this page was last updated. It is formatted as an ISO 8601 date time string (i.e. "2020-03-17T19:10:04.968Z"). The value of last_edited_time cannot be updated. See the Property Item Object to see how these values are returned.
}

func (_ *LastEditedTimePropertyValue) isPropertyValue() {}

// for binding
func (o *LastEditedTimePropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.LastEditedTime)
}

// for binding
func (o *LastEditedTimePropertyValue) set(v reflect.Value) {
	o.LastEditedTime = v.Interface().(ISO8601String)
}

// Last edited by property values
type LastEditedByPropertyValue struct {
	PropertyValueCommon
	Type         alwaysLastEditedBy `json:"type"`
	LastEditedBy User               `json:"last_edited_by"` //  Last edited by property value objects contain a user object within the last_edited_by property. The user object describes the user who last updated this page. The value of last_edited_by cannot be updated. See the Property Item Object to see how these values are returned.
}

func (_ *LastEditedByPropertyValue) isPropertyValue() {}

// for binding
func (o *LastEditedByPropertyValue) get() reflect.Value {
	return reflect.ValueOf(o.LastEditedBy)
}

// for binding
func (o *LastEditedByPropertyValue) set(v reflect.Value) {
	o.LastEditedBy = v.Interface().(User)
}

// UnmarshalJSON assigns the appropriate implementation to interface field(s)
func (o *LastEditedByPropertyValue) UnmarshalJSON(data []byte) error {
	type Alias LastEditedByPropertyValue
	t := &struct {
		*Alias
		LastEditedBy userUnmarshaler `json:"last_edited_by"`
	}{Alias: (*Alias)(o)}
	if err := json.Unmarshal(data, t); err != nil {
		return fmt.Errorf("unmarshaling LastEditedByPropertyValue: %w", err)
	}
	o.LastEditedBy = t.LastEditedBy.value
	return nil
}
