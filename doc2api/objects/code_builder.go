package objects

import (
	"fmt"
	"os"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/samber/lo"
	"github.com/stoewer/go-strcase"
)

// CodeBuilder は
// builderは生成されるオブジェクトやフィールドの依存関係の構築を行います
// 実行時にオブジェクトが登録される順番が一定しなくても、出力されるソースコードは変化しません
type CodeBuilder struct {
	converter *Converter // TODO これを保持しないことはできる？試してみる
	url       string
	fileName  string
	symbols   []Symbol
}

func (b *CodeBuilder) AddSimpleObject(name string, comment string) *SimpleObject {
	obj := &SimpleObject{}
	obj.name_ = strings.TrimSpace(name)
	obj.comment = comment
	b.symbols = append(b.symbols, obj)
	return obj
}

type addUnionStructOption func(o *UnionStruct)

func DiscriminatorOmitEmpty() addUnionStructOption {
	return func(o *UnionStruct) {
		for _, f := range o.fields {
			switch f := f.(type) {
			case *VariableField:
				if f.name == o.discriminator {
					f.omitEmpty = true
				}
			}
		}
	}
}

func Generic(constraint jen.Code) addUnionStructOption {
	return func(o *UnionStruct) {
		o.genericConstraint = constraint
	}
}

func (b *CodeBuilder) AddUnionStruct(name string, discriminator string, comment string, options ...addUnionStructOption) *UnionStruct {
	if discriminator == "" {
		panic(fmt.Errorf("%s のdiscriminatorは省略できません。", name))
	}

	o := &UnionStruct{discriminator: discriminator}
	o.name_ = name
	o.comment = comment
	o.AddFields(&VariableField{name: discriminator, typeCode: jen.String()})

	for _, option := range options {
		option(o)
	}
	b.symbols = append(b.symbols, o)
	return o
}

func (b *CodeBuilder) output(sortSymbols bool) {
	if sortSymbols {
		slices.SortFunc(b.symbols, func(a, b Symbol) int {
			return strings.Compare(a.name(), b.name())
		})
	}

	filePath := fmt.Sprintf("../../%s", b.fileName)

	if len(b.symbols) == 0 {
		_ = os.Remove(filePath)
	} else {
		file := jen.NewFile("notion")
		file.HeaderComment("Code generated by notion.doc2api; DO NOT EDIT.")
		if b.url != "" {
			file.HeaderComment(b.url)
		}
		for _, s := range b.symbols {
			file.Line().Line().Add(s.code(b.converter))
		}
		lo.Must0(file.Save(filePath))
	}
}

// asField は、このドキュメントに書かれたパラメータを、渡されたタイプに従ってGoコードのフィールドに変換します
func (*CodeBuilder) NewField(p *Parameter, typeCode jen.Code, options ...fieldOption) *VariableField {
	f := &VariableField{
		name:     p.Property,
		typeCode: typeCode,
		comment:  p.Description,
	}
	for _, o := range options {
		o(f)
	}
	return f
}

type fieldOption func(f *VariableField)

var OmitEmpty fieldOption = func(f *VariableField) {
	f.omitEmpty = true
}

var DiscriminatorNotEmpty fieldOption = func(f *VariableField) {
	f.discriminatorNotEmpty = true
}

func DiscriminatorValue(value string) fieldOption {
	return func(f *VariableField) {
		f.discriminatorValue = value
	}
}

func (b *CodeBuilder) NewSpecificObject(parent symbolWithFields, discriminatorValue string, comment string) *SimpleObject {
	objName := parent.name() + strcase.UpperCamelCase(discriminatorValue)
	parent.AddFields(&VariableField{
		name:      discriminatorValue,
		typeCode:  jen.Op("*").Id(objName),
		comment:   comment,
		omitEmpty: true, // TODO SimpleObjectのときはtrue、Adaptiveのときはfalseにすれば動くけど…
	})
	return b.AddSimpleObject(objName, comment)
}
