package objects

import (
	"fmt"
	"os"
	"slices"
	"strings"

	"github.com/dave/jennifer/jen"
	"github.com/samber/lo"
	"github.com/stoewer/go-strcase"
)

// CodeBuilder は
// builderは生成されるオブジェクトやフィールドの依存関係の構築を行います
// 実行時にオブジェクトが登録される順番が一定しなくても、出力されるソースコードは変化しません
type CodeBuilder struct {
	converter *Converter // TODO これを保持しないことはできる？試してみる
	url       string
	fileName  string
	symbols   []Symbol
}

func (b *CodeBuilder) AddSimpleObject(name string, comment string) *SimpleObject {
	obj := &SimpleObject{}
	obj.name_ = strings.TrimSpace(name)
	obj.comment = comment
	b.symbols = append(b.symbols, obj)
	b.converter.symbols.Store(name, obj)
	return obj
}

type addUnionStructOption func(o *UnionStruct)

func DiscriminatorOmitEmpty() addUnionStructOption {
	return func(o *UnionStruct) {
		for _, f := range o.fields {
			switch f := f.(type) {
			case *VariableField:
				if f.name == o.discriminator {
					f.omitEmpty = true
				}
			}
		}
	}
}

func Generic(constraint jen.Code) addUnionStructOption {
	return func(o *UnionStruct) {
		o.genericConstraint = constraint
	}
}

func (b *CodeBuilder) AddUnionStruct(name string, discriminator string, comment string, options ...addUnionStructOption) *UnionStruct {
	if discriminator == "" {
		panic(fmt.Errorf("%s のdiscriminatorは省略できません。", name))
	}

	o := &UnionStruct{discriminator: discriminator}
	o.name_ = name
	o.comment = comment
	o.AddFields(&VariableField{name: discriminator, typeCode: jen.String()})

	for _, option := range options {
		option(o)
	}
	b.symbols = append(b.symbols, o)
	b.converter.symbols.Store(name, o) // TODO UnionStructを保存する理由はないかもしれない
	return o
}

func (b *CodeBuilder) AddUnmarshalTest(targetName string, jsonCode string, typeArg ...string) {
	ut := &UnmarshalTest{targetName: targetName} // UnmarshalTestを作る
	if len(typeArg) != 0 {
		ut.typeArg = typeArg[0]
	}

	if exists := b.converter.getUnmarshalTest(ut.name()); exists != nil { // 同名のものが既にあるなら
		exists.jsonCodes = append(exists.jsonCodes, jsonCode) // JSONコードだけ追加
	} else { // 無ければ追加
		ut.jsonCodes = append(ut.jsonCodes, jsonCode)
		b.converter.symbols.Store(ut.name(), ut)
		b.converter.globalTestBuilder.symbols = append(b.converter.globalTestBuilder.symbols, ut)
	}
}

func (b *CodeBuilder) output(sortSymbols bool) {
	if sortSymbols {
		slices.SortFunc(b.symbols, func(a, b Symbol) int {
			return strings.Compare(a.name(), b.name())
		})
	}

	filePath := fmt.Sprintf("../../%s", b.fileName)

	if len(b.symbols) == 0 {
		_ = os.Remove(filePath)
	} else {
		file := jen.NewFile("notion")
		file.HeaderComment("Code generated by notion.doc2api; DO NOT EDIT.")
		if b.url != "" {
			file.HeaderComment(b.url)
		}
		for _, s := range b.symbols {
			file.Line().Line().Add(s.code(b.converter))
		}
		lo.Must0(file.Save(filePath))
	}
}

// asField は、このドキュメントに書かれたパラメータを、渡されたタイプに従ってGoコードのフィールドに変換します
func (*CodeBuilder) NewField(p *Parameter, typeCode jen.Code, options ...fieldOption) *VariableField {
	f := &VariableField{
		name:     p.Property,
		typeCode: typeCode,
		comment:  p.Description,
	}
	for _, o := range options {
		o(f)
	}
	return f
}

type fieldOption func(f *VariableField)

var OmitEmpty fieldOption = func(f *VariableField) {
	f.omitEmpty = true
}

var DiscriminatorNotEmpty fieldOption = func(f *VariableField) {
	f.discriminatorNotEmpty = true
}

func DiscriminatorValue(value string) fieldOption {
	return func(f *VariableField) {
		f.discriminatorValue = value
	}
}

// NewDiscriminatorField は、ドキュメントに書かれたパラメータを、渡されたタイプに従ってGoコードのフィールドに変換します
// TODO converterのメソッドにすべきでは
func (b *CodeBuilder) NewDiscriminatorField(p *Parameter) *DiscriminatorField {
	for _, value := range []string{p.ExampleValue, p.Type} {
		if value != "" {
			if strings.HasPrefix(value, `"`) && strings.HasSuffix(value, `"`) {
				value = strings.TrimPrefix(strings.TrimSuffix(value, `"`), `"`)

				{
					as := DiscriminatorString(value)
					if _, ok := b.converter.symbols.Load(as.name()); !ok {
						b.converter.symbols.Store(as.name(), as)
						b.converter.globalBuilder.symbols = append(b.converter.globalBuilder.symbols, as)
					}
				}

				return &DiscriminatorField{
					name:    p.Property,
					value:   value,
					comment: p.Description,
				}
			}
			panic(value)
		}
	}
	panic(fmt.Errorf("パラメータ %v には文字列リテラルが含まれません", p))
}

func (b *CodeBuilder) NewSpecificObject(parent symbolWithFields, discriminatorValue string, comment string) *SimpleObject {
	objName := parent.name() + strcase.UpperCamelCase(discriminatorValue)
	parent.AddFields(&VariableField{
		name:      discriminatorValue,
		typeCode:  jen.Op("*").Id(objName),
		comment:   comment,
		omitEmpty: true, // TODO SimpleObjectのときはtrue、Adaptiveのときはfalseにすれば動くけど…
	})
	return b.AddSimpleObject(objName, comment)
}
