package objectdoc

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"

	"github.com/PuerkitoBio/goquery"
	"github.com/dave/jennifer/jen"
	"github.com/pkg/errors"
	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/parser"
	"github.com/yuin/goldmark/util"
)

var registeredTranslators []translator

type translator struct {
	url    string
	scopes []translationScope
}

func (t *translator) translate(global *builder) error {
	// URLの取得
	res, err := http.Get(t.url)
	if err != nil {
		return errors.Wrap(err, "fetch")
	}

	defer func() {
		_, _ = io.ReadAll(res.Body)
		_ = res.Body.Close()
	}()

	// goqueryでのパース
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		return errors.Wrap(err, "parseHTML")
	}

	// JSONパース
	ssrPropsBytes := []byte(doc.Find(`#ssr-props`).AttrOr("data-initial-props", ""))
	ssrProps := struct {
		Doc struct {
			Body string `json:"body"`
		} `json:"doc"`
	}{}
	if err := json.Unmarshal(ssrPropsBytes, &ssrProps); err != nil {
		return errors.Wrap(err, "unmarshalSSR")
	}

	// エレメント取り出し
	ren := &docRenderer{}
	md := goldmark.New(
		goldmark.WithParserOptions(parser.WithBlockParsers(util.Prioritized(&specialBlockParser{}, 0))),
		goldmark.WithRenderer(ren),
	)
	if err := md.Convert([]byte(ssrProps.Doc.Body), bytes.NewBuffer(nil)); err != nil {
		return errors.Wrap(err, "markdown")
	}

	// スコープ実行
	c := &comparator{elements: ren.elements}
	fileName := "object." + strings.TrimPrefix(t.url, "https://developers.notion.com/reference/") + ".go"
	b := &builder{
		global:        global,
		globalSymbols: global.globalSymbols,
		fileName:      "../../" + fileName,
		url:           t.url,
	}

	var compareErr error
	for i, scope := range t.scopes {
		func() {
			defer func() {
				if err := recover(); err != nil {
					compareErr = fmt.Errorf("scope[%d]: %s", i, err)
				}
			}()
			scope(c, b)
		}()
		if compareErr != nil {
			return compareErr
		}
	}
	if c.index < len(c.elements) {
		f := jen.NewFile("template")
		f.Var().Id("ADD_THIS").Op("=").Index().Id("translationScope").ValuesFunc(func(g *jen.Group) {
			for _, elem := range c.elements[c.index:] {
				g.Line().Func().Params(jen.Id("c").Op("*").Id("comparator"), jen.Id("b").Op("*").Id("builder")).Block(elem.template())
			}
			g.Line()
		})
		if err := f.Save("tmp/" + fileName); err != nil {
			return err
		}
		return fmt.Errorf("%d element(s) remains", len(c.elements)-c.index)
	}

	if len(b.localSymbols) != 0 {
		file := jen.NewFile("notion")
		file.Comment("Code generated by notion.doc2api; DO NOT EDIT.")
		if b.url != "" {
			file.Comment(b.url)
		}
		for _, s := range b.localSymbols {
			file.Line().Line().Add(s.symbolCode(b))
		}
		if err := file.Save(b.fileName); err != nil {
			return err
		}
	} else {
		_ = os.Remove(b.fileName)
	}

	// テストコード
	if len(b.testSymbols) != 0 {
		file := jen.NewFile("notion")
		file.Comment("Code generated by notion.doc2api; DO NOT EDIT.")
		if b.url != "" {
			file.Comment(b.url)
		}
		for _, s := range b.testSymbols {
			file.Line().Line().Add(s.symbolCode(b))
		}
		if err := file.Save(strings.Replace(b.fileName, ".go", "_test.go", 1)); err != nil {
			return err
		}
	} else {
		_ = os.Remove(strings.Replace(b.fileName, ".go", "_test.go", 1))
	}

	return nil // OK
}

type translationScope func(c *comparator, b *builder)

func registerTranslator(url string, scopes ...translationScope) {
	registeredTranslators = append(registeredTranslators, translator{url: url, scopes: scopes})
}

func translateAll() error {
	global := &builder{
		globalSymbols: &sync.Map{},
		fileName:      "../../object.global.go",
	}
	for _, t := range registeredTranslators {
		if err := t.translate(global); err != nil {
			return errors.Wrap(err, t.url)
		}
	}
	return nil
}
